<!doctype html><html lang=en-us><head><title>kexec // Rahul Rameshbabu</title>
<link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.121.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Rahul Rameshbabu"><meta name=description content><link rel=stylesheet href=/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css><meta name=twitter:card content="summary"><meta name=twitter:title content="kexec"><meta name=twitter:description content="What is kexec? kexec is short for kernel execute. At a high level, it is analogous with the syscall exec. kexec replaces the memory of the currently loaded kernel image and begins executing the newly loaded kernel image. tl;dr it enables users to run new kernels without needing to do a full power cycle of a system.
What is the value of kexec? Enables a &#34;boot once&#34; flow for testing a potentially problematic kernel."><meta property="og:title" content="kexec"><meta property="og:description" content="What is kexec? kexec is short for kernel execute. At a high level, it is analogous with the syscall exec. kexec replaces the memory of the currently loaded kernel image and begins executing the newly loaded kernel image. tl;dr it enables users to run new kernels without needing to do a full power cycle of a system.
What is the value of kexec? Enables a &#34;boot once&#34; flow for testing a potentially problematic kernel."><meta property="og:type" content="article"><meta property="og:url" content="https://binary-eater.github.io/posts/kexec/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-10T21:32:56-08:00"><meta property="article:modified_time" content="2023-12-10T21:32:56-08:00"></head><body><header class=app-header><a href=https://binary-eater.github.io/><img class=app-header-avatar src=/avatar.jpg alt="Rahul Rameshbabu"></a>
<span class=app-header-title>Rahul Rameshbabu</span><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>Binary-Eater: A developer focused on low-level programming</p><div class=app-header-social><a href=https://github.com/Binary-Eater target=_blank rel="noreferrer noopener me"><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>kexec</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 10, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://binary-eater.github.io/tags/kernel/>kernel</a></div></div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>What is kexec?</h2><div id=outline-text-headline-1 class=outline-text-2><p><code>kexec</code> is short for kernel execute. At a high level, it is analogous with the
syscall <code>exec</code>. <code>kexec</code> replaces the memory of the currently loaded kernel image
and begins executing the newly loaded kernel image. tl;dr it enables users to
run new kernels without needing to do a full power cycle of a system.</p></div></div><div id=outline-container-headline-2 class=outline-2><h2 id=headline-2>What is the value of kexec?</h2><div id=outline-text-headline-2 class=outline-text-2><ul><li><p>Enables a "boot once" flow for testing a potentially problematic kernel.</p><ul><li>No bootloader configuration required.</li></ul></li><li>Does not require a complete system reboot (BIOS boot) to swap between kernel
images for testing.</li><li>Lowers the difficulty for setting up ad-hoc kernel development environments
using the latest kernel source tree.</li></ul></div></div><div id=outline-container-headline-3 class=outline-2><h2 id=headline-3>What is required to use kexec?</h2><div id=outline-text-headline-3 class=outline-text-2><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Kconfig</h3><div id=outline-text-headline-4 class=outline-text-3><p>The kernel that will have its image rewritten (the currently booted kernel) will
need the following kernel configuration options.</p><div class="src src-text"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  CONFIG_KEXEC=y      # Enables support for general kexec syscall functionality.
</span></span><span style=display:flex><span>  CONFIG_KEXEC_FILE=y # Enables kexec_file_load syscall. See the manual for kexec_load(2) for more details.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  # Optional security options
</span></span><span style=display:flex><span>  CONFIG_KEXEC_BZIMAGE_VERIFY_SIG=n # Verify the signing signature of the bzImage used in kexec
</span></span><span style=display:flex><span>  CONFIG_KEXEC_SIG=n                # If the kernel image has a signature, make sure the signature is valid when using the kexec_file_load syscall
</span></span><span style=display:flex><span>  CONFIG_KEXEC_SIG_FORCE=n          # Enforce that the kernel image used in the kexec_file_load syscall has a valid signature</span></span></code></pre></div></div></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Userspace</h3><div id=outline-text-headline-5 class=outline-text-3><p>You will need <code>kexec-tools</code> in userspace to be able to configure a kernel image
for <code>kexec</code>.</p></div></div></div></div><div id=outline-container-headline-6 class=outline-2><h2 id=headline-6>Using kexec</h2><div id=outline-text-headline-6 class=outline-text-2><p>Here is an example of setting up a new kernel image to execute in place of the
currently running image while reusing the kernel commandline of the previous
image.</p><div class="src src-sh"><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>  kexec -l /path/to/vmlinuz --initrd<span style=color:#f92672>=</span>/path/to/initramfs.img --reuse-cmdline
</span></span><span style=display:flex><span>  kexec -e</span></span></code></pre></div></div><p>The <code>--initrd</code> flag is optional. It is used when an initramfs image is needed to
properly bring up a system. <code>kexec -e</code> will then execute the configured kernel
without gracefully taking down any system services momentarily that might be
impacted.</p><p><code>systemd</code> can assist with a more graceful <code>kexec</code> flow for taking down services
and even supporting ad-hoc clean-up services using <code>WantedBy=kexec.target</code> in
the <code>Install</code> section of a systemd service definition. <code>kexec -e</code> is replaced
with <code>systemctl kexec</code>.</p><p>If you want to unload the target kernel that was previously loaded by <code>kexec</code>,
<code>kexec -u</code> will unload the currently running <code>kexec</code> target kernel.</p><p>There are a number of options for the <code>kexec</code> commandline tool that are
documented in the manual for <code>kexec(8)</code>.</p><p>Usage details for <code>kexec</code> are also well documented on the Arch Linux wiki and
Gentoo wiki.</p><p>OpenSUSE also has a more thorough <a href=https://documentation.suse.com/de-de/sles/15-GA/html/SLES-all/cha-tuning-kexec.html>write-up</a> on <code>kexec</code> and <code>kdump</code>.</p><p>NOTE: It seems Gentoo uses a patched version of <code>reboot</code> to offer a graceful
<code>-k</code> flag. Gentoo probably does this since it offers an alternative to
<code>systemd</code>, OpenRC.</p></div></div><div id=outline-container-headline-7 class=outline-2><h2 id=headline-7>Why is kexec not enabled everywhere?</h2><div id=outline-text-headline-7 class=outline-text-2><p>Lightly mentioned in this article already, <code>kexec</code> is not an infallible process.
This has to do with the fact that, unlike a userspace program that might have
its application instructions overwritten with an <code>exec</code> syscall, the kernel
image being overwritten is in charge of managing devices at a very low-level.
Device teardown and initialization may not occur in a way that leaves an
"already-running" system in a stable state.</p><p>The idea of being able to safely move to a different kernel without compromising
the system is called kernel livepatching. Kernel livepatching is a hot area of
research with multiple entities taking their own approaches on the matter.</p><ul><li><a href=https://ubuntu.com/blog/an-overview-of-live-kernel-patching>Canonical's solution without kexec by using ftrace hooking</a></li><li><a href=https://documentation.suse.com/sles/12-SP4/html/SLES-kgraft/index.html>kGraft by OpenSUSE that similarly uses ftrace hooking</a></li><li><a href=https://www.redhat.com/en/topics/linux/what-is-linux-kernel-live-patching#the-two-spaces-of-linux-system-operations>RedHat's ftrace hooking kpatch livepatch solution</a></li><li><a href=https://en.wikipedia.org/wiki/Ksplice#Design>Ksplice using its own injector and hooking mechanism</a></li></ul><p><strong>NOTE:</strong> Ksplice was initially developed by MIT students during its initial
development, as a reference illustrating that kernel livepatching is a topic
worth academic exploration.</p><p><strong>DISCLAIMER:</strong> I have not read any of the above approaches in detail. I just felt
I should draw attention to them for curious readers interested in ways to
potentially make <code>kexec</code> "more-robust".</p></div></div><div id=outline-container-headline-8 class=outline-2><h2 id=headline-8>Alternatives to kexec</h2><div id=outline-text-headline-8 class=outline-text-2><p>For "boot once" testing, using bootloader configurations to do a "boot once" is
an option. However, many bootloaders have an involved process for achieving
this.</p><p>I have not found decent documentation on how to do this for GRUB 2 (not GRUB
Legacy). In reality, I might work with a number of systems using different
bootloaders such as <code>systemd-boot</code> and learning how to do this with every
bootloader implementation out there seems like an adventure.</p></div></div></div><div class=post-footer></div></article></main></body></html>